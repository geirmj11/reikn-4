\documentclass[11pt]{article}
\usepackage[icelandic]{babel}
\usepackage{amsmath}
\usepackage{array}
\usepackage[margin=1in]{geometry}            
\geometry{a4paper} 
\setlength{\parindent}{0mm}
\usepackage[T1]{fontenc}
\usepackage{fourier}
\usepackage[condensed]{kurier}
%fyrir myndir
\usepackage[pdftex]{graphicx}
\usepackage[table]{xcolor}

\usepackage{pgf}
\usepackage[utf8]{inputenc}
\usepackage{listings}

\pagestyle{headings}

\usepackage{fancyhdr}
\setlength{\headheight}{25.5pt}
\pagestyle{fancy}
%\usetikzlibrary{arrows, shapes, positioning}
% Pages styles

\title{Programming Assignment 4}
\author{}
\date{}

\lhead[lh-even]{T-301-REIR - Fall 2012 \\ Programming Assignment #4}
\rhead[rh-even]{Geir Matti Järvelä (geirmj11@ru.is) \\ Þorgeir Auðunn Karlsson (thorgeirk11@ru.is)}

\begin{document}
\section*{\centering Programming Assignment #4: Properties of Social Networks}
For the assignment we created three classes, explained further below. All of the classes implement an intelligent lazy solution to each problem.
In effect this means that all calculations are done at most once, and only when they are needed.
Each method checks first if a solution exists, and if so simply returns a previously calculated solution. This method costs a little bit
more in memory, since previous solutions need to be kept, but makes up for it with constant calculating times when duplicating previous calculations, or when 
two functions use the same results.

\subsubsection*{Part I - The Centrality class}
public Centrality(Graph G) \\
public int degree(int v) \\
public int ecc(int v) \\
public int effEcc(int v) \\
public double closeness(int v) \\
public int popularVertex() \\
public int center() \\
public int effCenter() \\
public int closest()

\subsubsection*{Efficiency of methods}
\begin{minipage}[b]{0.5\linewidth}
The numbers in the table on the right show the complexity of each method, for the first time each method is called. 
However some of the methods call other methods for every point, for example the closest() method calls the closeness() function for every point in the graph,
and since the results are stored, they can be accessed directly thereafter. \\ \\ 
\end{minipage}
\begin{minipage}[b]{0.5\linewidth}\centering
\scalebox{0.7}{
\begin{tabular}{l|cc}
    Method & Initial Complexity & Subsequent\\
	\hline
	 Constructor            & $10$                  & constant\\
	 Degree                 & $\sim V$              & constant\\
	 Eccentricity           & $\sim2V+E$            & constant\\
	 Effective Eccentricity & $\sim V(\log V)$      & constant\\ %3V+E+V(log V)
	 Closeness              & $\sim2V+E$            & constant\\
	 Most Popular Vertex    & $\sim V^2$            & constant\\
	 Center                 & $\sim V$              & constant\\
	 Effective Center       & $\sim V(V(\log V)) $  & constant\\
	 Closest Vertex         & $\sim V(V+E)$         & constant\\
	 \hline
\end{tabular}
}
\small{Complexity table: $V$: Number of Vertices \\$E$: Number of Edges.} \\ \\ 
\end{minipage}

\subsubsection*{Part II - The SymbolCentrality class}
The SymbolCentrality class is simply an extention of Centrality. It creates a Symbolgraph class instance, and uses it to create indexed integer keys for each actor.\\
This allows the class to use the methods of the Centrality class to calculate all necessary values.
\subsubsection*{Efficiency}
Since each function calls the sg.index() method, this adds log(n) complexity to each operation of the Centrality class. 
In addition more memory is needed because of the SymbolGraph that stores the indices.

\subsubsection*{Part III - The ExtendedBreadthFirstPaths class}

\subsubsection*{Efficiency}

\end{document} 

